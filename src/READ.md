1.最简单的版本一边进行mmcs一遍进行refine的验证，每个节点都保存一个clusterPair
- 因为不一定保证需要combine的谓词能进行IEJoin，所以时间很容易退化为不包含IEJoin的只包含单个为此Refine的验证过程
- 在这里没有对初始的输入进行选择性的排序，对结果的影响也蛮大
- 最简单的版本在refine上速度很慢，所以不准备继续优化（选择谓词时的排序）

2.再进一步的版本就是，每次得到一个approx dc的时候进行验证，这样可以将深度遍历这一条路径上的
谓词进行排序和combine，然后进行IEJoin
- 对每次refine的结果进行保存，但是对于其他路径而言，有用的结果只是前缀解结果，也就是从
对初始化的clusterPair进行前面几个谓词或者谓词对的refine结果可以共用，如果排序后得到
前缀结果不一样，那么就又要重新算
- 因为每一条路径可能和其他几个路径有相同节点，但是因为存在不同的谓词加入
所以排序之后的执行顺序不一样了，会使得本来相同的前缀不一定相同
- 21.12.17刚写完第二个版本，但还没来的及调试就发现了不可行

3.第三个版本
- 先对样本集进行mmcs完全运行，得到approx dc类似于hydra的第一次inversion
- 然后用hydra的方法对所有的谓词和谓词对进行选择性计算，排序，然后进行验证，
为每个approx dc维护一个cluster pair，
- （可进行优化）对dc进行一定的排序
- 取出每个dc的cluster pair计算新的evidence set，然后类似插入一样去进行覆盖
期间维护一个new evidence set，每个dc取出来的时候先对前面dc新产生的evidence进行覆盖
- 在覆盖的时候不进行验证，这个时候会产生一棵新的以该dc为根节点的子树，在这棵子树上我们
可以重复第一步的选择性计算，排序，然后进行验证，然后又产生一批新的dc节点
- 重复第二步，进行子循环，直到cluster pair为空
- 套娃

Version3 optimistic
- 可以选择是直接计算evidence 还是继续使用验证，如果cluster pair比较小的话，明显直接计算要更好，valid比较慢
- 有些节点inverse之后会产生一样的dc，这样的节点可以删除
- 抽样可以尽量少但也不能太少，因为抽样得到的第一轮evidence的mmcs得到的dc是必须验证的，这个时间会很长，跟hydra差不多